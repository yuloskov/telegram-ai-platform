import type { NextApiResponse } from "next";
import { prisma } from "~/server/db";
import { withAuth, type AuthenticatedRequest } from "~/lib/auth";
import type { ApiResponse, PaginatedResponse } from "@repo/shared/types";

interface PostResponse {
  id: string;
  channelId: string;
  content: string;
  status: string;
  generationType: string;
  scheduledAt: string | null;
  publishedAt: string | null;
  telegramMessageId: string | null;
  errorMessage: string | null;
  isAutoGenerated: boolean;
  createdAt: string;
  updatedAt: string;
}

async function handler(
  req: AuthenticatedRequest,
  res: NextApiResponse<ApiResponse<PostResponse> | PaginatedResponse<PostResponse>>
) {
  const { user } = req;

  if (req.method === "GET") {
    const { channelId, status, page = "1", limit = "20" } = req.query;

    if (!channelId || typeof channelId !== "string") {
      return res.status(400).json({ success: false, error: "Channel ID is required" });
    }

    // Verify channel ownership
    const channel = await prisma.channel.findFirst({
      where: { id: channelId, userId: user.id },
    });

    if (!channel) {
      return res.status(404).json({ success: false, error: "Channel not found" });
    }

    const pageNum = parseInt(page as string, 10);
    const limitNum = parseInt(limit as string, 10);
    const skip = (pageNum - 1) * limitNum;

    const where = {
      channelId,
      ...(status && typeof status === "string" && { status: status as any }),
    };

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip,
        take: limitNum,
      }),
      prisma.post.count({ where }),
    ]);

    return res.status(200).json({
      success: true,
      data: posts.map((post) => ({
        id: post.id,
        channelId: post.channelId,
        content: post.content,
        status: post.status,
        generationType: post.generationType,
        scheduledAt: post.scheduledAt?.toISOString() ?? null,
        publishedAt: post.publishedAt?.toISOString() ?? null,
        telegramMessageId: post.telegramMessageId?.toString() ?? null,
        errorMessage: post.errorMessage,
        isAutoGenerated: post.isAutoGenerated,
        createdAt: post.createdAt.toISOString(),
        updatedAt: post.updatedAt.toISOString(),
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    });
  }

  if (req.method === "POST") {
    const { channelId, content, scheduledAt } = req.body;

    if (!channelId || !content) {
      return res.status(400).json({
        success: false,
        error: "Channel ID and content are required",
      });
    }

    // Verify channel ownership
    const channel = await prisma.channel.findFirst({
      where: { id: channelId, userId: user.id },
    });

    if (!channel) {
      return res.status(404).json({ success: false, error: "Channel not found" });
    }

    const post = await prisma.post.create({
      data: {
        channelId,
        content,
        status: scheduledAt ? "scheduled" : "draft",
        generationType: "manual",
        scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
      },
    });

    return res.status(201).json({
      success: true,
      data: {
        id: post.id,
        channelId: post.channelId,
        content: post.content,
        status: post.status,
        generationType: post.generationType,
        scheduledAt: post.scheduledAt?.toISOString() ?? null,
        publishedAt: post.publishedAt?.toISOString() ?? null,
        telegramMessageId: post.telegramMessageId?.toString() ?? null,
        errorMessage: post.errorMessage,
        isAutoGenerated: post.isAutoGenerated,
        createdAt: post.createdAt.toISOString(),
        updatedAt: post.updatedAt.toISOString(),
      },
    });
  }

  return res.status(405).json({ success: false, error: "Method not allowed" });
}

export default withAuth(handler);
