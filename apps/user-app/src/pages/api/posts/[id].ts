import type { NextApiResponse } from "next";
import { prisma } from "~/server/db";
import { withAuth, type AuthenticatedRequest } from "~/lib/auth";
import type { ApiResponse } from "@repo/shared/types";

interface PostResponse {
  id: string;
  channelId: string;
  content: string;
  status: string;
  generationType: string;
  scheduledAt: string | null;
  publishedAt: string | null;
  telegramMessageId: string | null;
  errorMessage: string | null;
  isAutoGenerated: boolean;
  createdAt: string;
  updatedAt: string;
}

async function handler(
  req: AuthenticatedRequest,
  res: NextApiResponse<ApiResponse<PostResponse>>
) {
  const { user } = req;
  const { id } = req.query;

  if (typeof id !== "string") {
    return res.status(400).json({ success: false, error: "Invalid post ID" });
  }

  // Get the post and verify ownership through channel
  const post = await prisma.post.findFirst({
    where: {
      id,
      channel: { userId: user.id },
    },
    include: { channel: true },
  });

  if (!post) {
    return res.status(404).json({ success: false, error: "Post not found" });
  }

  if (req.method === "GET") {
    return res.status(200).json({
      success: true,
      data: {
        id: post.id,
        channelId: post.channelId,
        content: post.content,
        status: post.status,
        generationType: post.generationType,
        scheduledAt: post.scheduledAt?.toISOString() ?? null,
        publishedAt: post.publishedAt?.toISOString() ?? null,
        telegramMessageId: post.telegramMessageId?.toString() ?? null,
        errorMessage: post.errorMessage,
        isAutoGenerated: post.isAutoGenerated,
        createdAt: post.createdAt.toISOString(),
        updatedAt: post.updatedAt.toISOString(),
      },
    });
  }

  if (req.method === "PUT" || req.method === "PATCH") {
    // Can only edit drafts and failed posts
    if (!["draft", "failed"].includes(post.status)) {
      return res.status(400).json({
        success: false,
        error: "Cannot edit a post that is not a draft or failed",
      });
    }

    const { content, scheduledAt, status } = req.body;

    const updated = await prisma.post.update({
      where: { id },
      data: {
        ...(content && { content }),
        ...(scheduledAt !== undefined && {
          scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
        }),
        ...(status && { status }),
      },
    });

    return res.status(200).json({
      success: true,
      data: {
        id: updated.id,
        channelId: updated.channelId,
        content: updated.content,
        status: updated.status,
        generationType: updated.generationType,
        scheduledAt: updated.scheduledAt?.toISOString() ?? null,
        publishedAt: updated.publishedAt?.toISOString() ?? null,
        telegramMessageId: updated.telegramMessageId?.toString() ?? null,
        errorMessage: updated.errorMessage,
        isAutoGenerated: updated.isAutoGenerated,
        createdAt: updated.createdAt.toISOString(),
        updatedAt: updated.updatedAt.toISOString(),
      },
    });
  }

  if (req.method === "DELETE") {
    // Can only delete drafts
    if (post.status !== "draft") {
      return res.status(400).json({
        success: false,
        error: "Cannot delete a post that is not a draft",
      });
    }

    await prisma.post.delete({ where: { id } });

    return res.status(200).json({
      success: true,
      message: "Post deleted successfully",
    });
  }

  return res.status(405).json({ success: false, error: "Method not allowed" });
}

export default withAuth(handler);
