import type { NextApiResponse } from "next";
import { prisma } from "~/server/db";
import { withAuth, type AuthenticatedRequest } from "~/lib/auth";
import type { ApiResponse } from "@repo/shared/types";

interface MediaFileResponse {
  id: string;
  url: string;
  type: string;
  isGenerated: boolean;
}

interface PostResponse {
  id: string;
  channelId: string;
  content: string;
  status: string;
  generationType: string;
  scheduledAt: string | null;
  publishedAt: string | null;
  telegramMessageId: string | null;
  errorMessage: string | null;
  isAutoGenerated: boolean;
  createdAt: string;
  updatedAt: string;
  mediaFiles: MediaFileResponse[];
}

async function handler(
  req: AuthenticatedRequest,
  res: NextApiResponse<ApiResponse<PostResponse>>
) {
  const { user } = req;
  const { id } = req.query;

  if (typeof id !== "string") {
    return res.status(400).json({ success: false, error: "Invalid post ID" });
  }

  // Get the post and verify ownership through channel
  const post = await prisma.post.findFirst({
    where: {
      id,
      channel: { userId: user.id },
    },
    include: { channel: true, mediaFiles: true },
  });

  if (!post) {
    return res.status(404).json({ success: false, error: "Post not found" });
  }

  if (req.method === "GET") {
    return res.status(200).json({
      success: true,
      data: {
        id: post.id,
        channelId: post.channelId,
        content: post.content,
        status: post.status,
        generationType: post.generationType,
        scheduledAt: post.scheduledAt?.toISOString() ?? null,
        publishedAt: post.publishedAt?.toISOString() ?? null,
        telegramMessageId: post.telegramMessageId?.toString() ?? null,
        errorMessage: post.errorMessage,
        isAutoGenerated: post.isAutoGenerated,
        createdAt: post.createdAt.toISOString(),
        updatedAt: post.updatedAt.toISOString(),
        mediaFiles: post.mediaFiles.map((mf) => ({
          id: mf.id,
          url: mf.url,
          type: mf.type,
          isGenerated: mf.isGenerated,
        })),
      },
    });
  }

  if (req.method === "PUT" || req.method === "PATCH") {
    // Can only edit drafts, failed, scheduled, and pending_review posts
    if (!["draft", "failed", "scheduled", "pending_review"].includes(post.status)) {
      return res.status(400).json({
        success: false,
        error: "Cannot edit a post that is already published or publishing",
      });
    }

    const { content, scheduledAt, status, mediaFiles: newMediaFiles } = req.body;

    // Handle media file updates if provided
    if (newMediaFiles && Array.isArray(newMediaFiles)) {
      // Delete existing media files
      await prisma.mediaFile.deleteMany({
        where: { postId: id },
      });

      // Create new media files
      if (newMediaFiles.length > 0) {
        await prisma.mediaFile.createMany({
          data: newMediaFiles.map((mf: { url: string; type?: string; isGenerated?: boolean }) => ({
            postId: id,
            url: mf.url,
            type: mf.type || "image",
            filename: mf.url.split("/").pop() || "image.png",
            isGenerated: mf.isGenerated ?? false,
          })),
        });
      }
    }

    const updated = await prisma.post.update({
      where: { id },
      data: {
        ...(content && { content }),
        ...(scheduledAt !== undefined && {
          scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
        }),
        ...(status && { status }),
      },
      include: { mediaFiles: true },
    });

    return res.status(200).json({
      success: true,
      data: {
        id: updated.id,
        channelId: updated.channelId,
        content: updated.content,
        status: updated.status,
        generationType: updated.generationType,
        scheduledAt: updated.scheduledAt?.toISOString() ?? null,
        publishedAt: updated.publishedAt?.toISOString() ?? null,
        telegramMessageId: updated.telegramMessageId?.toString() ?? null,
        errorMessage: updated.errorMessage,
        isAutoGenerated: updated.isAutoGenerated,
        createdAt: updated.createdAt.toISOString(),
        updatedAt: updated.updatedAt.toISOString(),
        mediaFiles: updated.mediaFiles.map((mf) => ({
          id: mf.id,
          url: mf.url,
          type: mf.type,
          isGenerated: mf.isGenerated,
        })),
      },
    });
  }

  if (req.method === "DELETE") {
    // Can only delete drafts
    if (post.status !== "draft") {
      return res.status(400).json({
        success: false,
        error: "Cannot delete a post that is not a draft",
      });
    }

    await prisma.post.delete({ where: { id } });

    return res.status(200).json({
      success: true,
      message: "Post deleted successfully",
    });
  }

  return res.status(405).json({ success: false, error: "Method not allowed" });
}

export default withAuth(handler);
